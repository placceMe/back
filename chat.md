# Технічне завдання (ТЗ)
## Модуль: Чати по товарах (EF Core + SignalR)

### 1. Мета
Реалізувати модуль персональних чатів між покупцем і продавцем у розрізі конкретного товару. Зберігання – EF Core + PostgreSQL. Відправлення повідомлень – через HTTP POST. SignalR відповідає за трансляцію подій у реальному часі.

> Вихідний етап без авторизації, модерації та файлів. Передбачити розширення на JWT/ролі, модерацію та вкладення в наступних ітераціях.

---

### 2. Обсяг робіт (Scope)
- Схема БД та EF Core моделі для чатів і повідомлень.
- REST API для створення/отримання чатів та стрічки повідомлень, відправлення повідомлень через POST.
- SignalR-хаб з приєднанням до групи чату та трансляцією подій MessageCreated.
- Пагінація та індексація.
- Валідації та бізнес-правила.

Out of scope (на цей етап):
- Авторизація/ACL, модерація, вкладення файлів, push/e-mail нотифікації, пошук по повідомленнях, редагування/видалення повідомлень, статус «набирає» (Typing), непрочитані/прочитані.

---

### 3. Сутності і моделі (EF Core)
> Ідентифікатори – UUID (Guid). Час – UTC.

#### 3.1. Chat (чат по товару)
Призначення: унікальний канал між продавцем і покупцем по конкретному товару.

Поля:
- Id — первинний ключ.
- ProductId — посилання на товар (зовнішній сервіс Products).
- SellerId — посилання на продавця (зовнішній сервіс Users/Sellers).
- BuyerId — посилання на покупця (зовнішній сервіс Users).
- CreatedAt — дата/час створення (UTC, встановлюється в БД).

Обмеження та правила:
- Унікальність: один чат на трійку (ProductId, SellerId, BuyerId).
- Цілісність ролей: SellerId має відповідати продавцю товару з ProductId (перевірка на рівні сервісу при створенні чату).
- Каскадне видалення: при видаленні чату — видаляються його повідомлення.

Індекси:
- Унікальний індекс на (ProductId, SellerId, BuyerId).
- Індекси за SellerId, BuyerId для швидких вибірок списків чатів.

Зв’язки:
- Chat 1→N ChatMessage.

#### 3.2. ChatMessage (повідомлення)
Призначення: атомарне повідомлення у рамках одного чату.

Поля:
- Id — первинний ключ.
- ChatId — FK → Chat.Id.
- SenderUserId — ідентифікатор відправника (користувач із зовнішнього сервісу Users).
- Body — текст повідомлення (обов’язкове, макс. 4000 символів, без HTML-розмітки на першому етапі).
- CreatedAt — дата/час створення (UTC, встановлюється в БД).

Обмеження та правила:
- Порожні/пробільні повідомлення заборонені.
- Максимальна довжина: 4000 символів (налаштовується константою).

Індекси:
- Композитний індекс (ChatId, CreatedAt) для сортування та пагінації.

Зв’язки:
- N→1 до Chat (обов’язковий).

> Примітка: На етапі MVP не зберігаємо статуси «прочитано/непрочитано» та не ведемо учасників/лічильники. Це можна додати у наступній версії через моделі ChatParticipant, ChatMessageRead.

---

### 4. Схема БД (PostgreSQL, логічний опис)
Схема за замовчуванням: chat_service (можна змінити).

Таблиця `Chats`:
- Id (uuid, PK)
- ProductId (uuid, not null)
- SellerId (uuid, not null)
- BuyerId (uuid, not null)
- CreatedAt (timestamptz, not null, default `now() at time zone 'utc'`)
- Унікальний ключ (ProductId, SellerId, BuyerId)
- Індекси: (SellerId), (BuyerId)

Таблиця `ChatMessages`:
- Id (uuid, PK)
- ChatId (uuid, not null, FK → Chats.Id on delete cascade)
- SenderUserId (uuid, not null)
- Body (text, not null, max 4000 симв.)
- CreatedAt (timestamptz, not null, default `now() at time zone 'utc'`)
- Індекс (ChatId, CreatedAt)

---

### 5. REST API (контракти без коду)
Базовий шлях: /api.
#### 5.1. Створення/отримання чату
- POST /api/chats
- Вхід: productId, sellerId, buyerId (UUID).
- Поведінка: якщо чат із такою трійкою існує — повернути його; інакше створити і повернути.
- Валідації: усі поля обов’язкові; перевірити відповідність sellerId продавцю товару productId (на етапі MVP — припускаємо коректність або робимо просту перевірку за наявними даними).
- Вихід: об’єкт чату (`id`, productId, sellerId, buyerId, `createdAt`).
- Коди відповіді: 200 OK (існуючий або новий), 400 Bad Request (валідація).

#### 5.2. Отримання списку чатів
- GET /api/chats
- Параметри запиту (опційні):
  - userId — повертає чати де BuyerId = userId або SellerId = userId.
  - sellerId — фільтр по продавцю.
  - buyerId — фільтр по покупцю.
  - cursor — курсор пагінації (див. нижче).
  - limit — кількість, дефолт 20, макс. 100.
- Сортування: за CreatedAt (desc) або за останнім повідомленням у наступній ітерації.
- Вихід: масив чатів (легка DTO, без повідомлень).

#### 5.3. Деталі чату
- GET /api/chats/{chatId}
- Вихід: повний опис чату (без повідомлень).
- Коди: 200 OK, 404 Not Found.

#### 5.4. Отримання повідомлень чату
- GET /api/chats/{chatId}/messages
- Параметри запиту:
  - after — курсор (ISO8601 datetime або пара createdAt`+`id у наступній ітерації).
  - limit — дефолт 50, макс. 200.
- Сортування: зростання за часом (`CreatedAt asc`).
- Вихід: масив повідомлень (`id`, chatId, senderUserId, body, `createdAt`).
- Коди: 200 OK, 404 Not Found (якщо чату не існує).

#### 5.5. Надсилання повідомлення (через POST)
- POST /api/chats/{chatId}/messages
- Вхід: senderUserId (UUID), body (string).
- Валідації: body не порожній і ≤4000 символів.
- Поведінка: створити повідомлення у БД; викликати трансляцію через SignalR (подія `MessageCreated`).
- Вихід: об’єкт створеного повідомлення (`id`, chatId, senderUserId, body, `createdAt`).
- Коди: 200 OK, 400 Bad Request (валідація), 404 Not Found (чат відсутній).

Пагінація:
- На першому етапі допускається пагінація по CreatedAt з параметром after як datetime.
- Рекомендація до наступної ітерації: курсор (\"createdAt\",\"id\") для унікального порядку, без пропусків.

Формат помилок:
- Єдиний формат з полями code, message, details (узгодити з усім бекендом).

---

### 6. SignalR (контракти подій)
Хаб: /hubs/chat.

Групи:
- Для кожного чату — група з назвою chat:{chatId}.

Методи клієнта → хаб:
- JoinChat(chatId) — додати поточне з’єднання до групи чату. Якщо chatId не існує — повернути помилку.
- LeaveChat(chatId) — покинути групу.

Події хаба → клієнтам (broadcast у групу):
- MessageCreated — тіло події містить поля повідомлення: id, chatId, senderUserId, body, createdAt.

> Інші події (Typing, Edited, Deleted, Read) — out of scope на цей етап.

---

### 7. Валідації і бізнес-правила
- Створення чату: заборонити дублікати — спираємось на унікальність (ProductId, SellerId, BuyerId).
- Відправлення повідомлення: Body обов’язкове і не перевищує 4000 символів; SenderUserId обов’язковий.
- Порожні повідомлення/лише пробіли — блокувати.
- Повідомлення створюється лише у наявному чаті (`404`, якщо нема).

---

### 8. Нефункціональні вимоги
- Продуктивність: індекси, ліміти limit (≤200), розумні таймаути.
- Надійність: транзакційність для створення повідомлення; унікальність чату на рівні БД.
- Масштабування: передбачити Redis Backplane для SignalR у майбутньому.
- Логи: події створення чатів і повідомлень логуються (рівень Info), помилки — Error; кореляційний TraceId.
- Час: усі дати — UTC. Формат відповіді — ISO 8601.

---

### 9. Міграції та ініціалізація
- Створити міграції для Chats і ChatMessages з описаними індексами, FK та дефолтами часу (UTC).
- Забезпечити створення схеми chat_service (якщо використовується підхід \"schema-per-service\").

---
### 10. Приймальні критерії (Acceptance Criteria)
1. POST /api/chats повертає існуючий чат або створює новий; повторні виклики з тією ж трійкою не створюють дублікати.
2. GET /api/chats повертає відсортований список з можливістю фільтрації за userId`/`sellerId`/`buyerId і пагінації.
3. GET /api/chats/{chatId}/messages повертає масив повідомлень у правильному порядку з пагінацією.
4. POST /api/chats/{chatId}/messages створює повідомлення, зберігає його в БД та розсилає подію MessageCreated у SignalR групу чату.
5. Помилки валідації повертаються у єдиному форматі з коректними кодами HTTP.

---

### 11. Подальше розширення (план)
- Додати ChatParticipant (роль, lastSeenAt, unreadCount) і ChatMessageRead для бейджів непрочитаних.
- Додати авторизацію (JWT), ACL за ролями (buyer/seller/moderator/admin).
- Додати файли/вкладення (інтеграція з FilesService/MinIO) і попередню валідацію типів.
- Додати антимат/фільтри, ліміти на швидкість, idempotency-key для POST повідомлень.
- Підтримати видалення/редагування повідомлень із аудитом.